import { sql } from '@vercel/postgres';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // If DB is not configured, this will throw. We can catch and return empty array.
    const { rows } = await sql`SELECT * FROM slides ORDER BY id ASC`;
    
    // Map snake_case to camelCase for frontend compatibility
    const slides = rows.map(row => ({
      id: row.id,
      title: row.title,
      subtitle: row.subtitle,
      image: row.image_url,
      ctaText: row.cta_text,
      ctaLink: row.cta_link
    }));

    return NextResponse.json(slides);
  } catch (error) {
    console.error('Database error:', error);
    // Fallback to empty array if table doesn't exist yet
    return NextResponse.json([]);
  }
}

export async function POST(request) {
  try {
    const slides = await request.json();
    
    // Simplest approach: Delete all and re-insert (for simple ordering/sync)
    // Or we could upsert. Since the frontend sends the whole list, full sync is easiest.
    // However, for efficiency, maybe just upsert.
    // But let's stick to full sync for simplicity with re-ordering.
    // Actually, 'slides' input might have new items without IDs (if generated by frontend using Date.now() but backend expects serial)
    
    // Transactional approach would be better but Vercel SQL is HTTP based.
    
    // Let's just handle updates one by one or do a clean slate approach. 
    // Clean slate is risky if something fails mid-way.
    
    // Better strategy for this specific "Admin edits all slides" UI:
    // 1. We receive the full new state.
    // 2. We can truncate and re-insert. (Fastest for small datasets < 10 items).
    
    await sql`TRUNCATE TABLE slides`;
    
    for (const slide of slides) {
      await sql`
        INSERT INTO slides (title, subtitle, image_url, cta_text, cta_link)
        VALUES (${slide.title}, ${slide.subtitle}, ${slide.image}, ${slide.ctaText}, ${slide.ctaLink})
      `;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Database error:', error);
    return NextResponse.json({ success: false, error: error.message }, { status: 500 });
  }
}
